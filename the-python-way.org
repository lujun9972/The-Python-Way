#+TITLE: the-python-way
#+AUTHOR: lujun9972
#+CATEGORY: Python
#+DATE: [2016-05-01 日 10:14]
#+OPTIONS: ^:{}

* Pythonic Code

** Python代码规范
+ 包和模块的命名采用小谢,单数形式,而且短小
+ 包仅作为命名空间,即只包含空的__init__.py文件
** for循环
python的 ~for~ 与C++中的for是不同的,它专指 "for each"

+ 若只想遍历list中的元素,只需要使用 =for in= 便利即可

  #+BEGIN_SRC python
    for i in ['a' , 'b' , 'c']:
        print(i)
  #+END_SRC

  #+RESULTS:
  : a
  : b
  : c

+ 若想同时遍历多个list,使用 ~for~ 与 ~zip~ 组合
  #+BEGIN_SRC python
    l1 = ["a","b","c","d","e"]
    l2 = ["A","B","C","D","E"]
    l3 = ["甲","乙","丙","丁","戊"]

    for i in zip(l1,l2,l3):
        print(i)

  #+END_SRC

  #+RESULTS:
  : ('a', 'A', '甲')
  : ('b', 'B', '乙')
  : ('c', 'C', '丙')
  : ('d', 'D', '丁')
  : ('e', 'E', '戊')

+ 若想便利list中的元素同时还需要元素的索引,使用 ~for~ 与 ~enumerate~
  #+BEGIN_SRC python
    l1 = ["a","b","c","d","e"]

    for index,value in enumerate(l1,start=1):
        print(index,value)

  #+END_SRC

  #+RESULTS:
  : 1 a
  : 2 b
  : 3 c
  : 4 d
  : 5 e

** 连续比较
这是诸多语言中少有的简便方法
#+BEGIN_SRC python
  print(3>2>1>0)
  print(1<2>0)
#+END_SRC

#+RESULTS:
: True
: True

** 交换变量
Python支持直接交换变量
#+BEGIN_SRC python
  a,b = 1,2
  print(a,b)
  a,b = b,a
  print(a,b)
#+END_SRC

#+RESULTS:
: 1 2
: 2 1

** 格式化输出
一般使用string的format方法进行格式化输出
#+BEGIN_SRC python
  # {}的内容会被format()中的参赛所替代
  print('{} is a {}'.format('Cescfangs','gooner'))

  # 可以在{}里填上数字来指定format()中的第几个参赛
  print('{1} is a {0}'.format('gooner','Cescfangs'))

  # 若{}里填上的是参数名,则会使用format中的同名函数的值
  print('{Ramsey} is a {gunner}'.format(gunner='gooner',Ramsey='Cescfangs'))

  # 还可以使用:对输出的范围进行控制,我们输出pi的小数点后三位
  import math
  print('value of pi is {0:.3f}'.format(math.pi))

  # :还可以起到输出固定位数的作用
  arsenal = {'Ramsey':16,'Rosciky':7,'Chambers':21,'Ozil':11}
  for player,number in arsenal.items():
      print('{0:10}-->{1:3d}'.format(player,number))

#+END_SRC

#+RESULTS:
: Cescfangs is a gooner
: Cescfangs is a gooner
: Cescfangs is a gooner
: value of pi is 3.142
: Chambers  --> 21
: Ozil      --> 11
: Ramsey    --> 16
: Rosciky   -->  7

** ++i 不等于 i+=1
Python不支持 =++/--= 操作,因此会将 =++i= 解释成 =+(+i)= ,其中+表示正数符号. 
#+BEGIN_SRC python
  i = 1
  print(+1)
  print(++1)
  print(+++1)
#+END_SRC

#+RESULTS:
: 1
: 1
: 1

对于 =--i= 也是类似 

** 使用with自动关闭资源
with语句的语法为:
#+BEGIN_SRC python
  with expr1 [as e1[,expr2 as e2]]:
      codes
#+END_SRC

其中expr应该返回一个上下文对象,这个对象定义了 =__exit__()= 和 =__exit__()= 方法

+ __enter__()

  进入运行时的上下文,返回运行时上下文相关的对象,with语句会将这个返回值绑定到目标对象上.

+ __exit__(exception_type,exception_value,traceback)

  退出运行时的上下文,定义在code执行之后上下文管理器应该做什么.

为了更好地辅助上下文管理,Python还提供了contextlib模块,该模块中的contentmanager作为装饰器可以提供一种针对函数j级别的上下文管理机制,可以直接作用于函数/对象而不用去关心__enter()__和__exit__()方法的具体实现

** 三元操作符"?:"

Python本身不支持三元操作符 =?:= . =C?X:Y= 在Python中等价形式为 =X if C else Y=
#+BEGIN_SRC python
  X = 0
  Y = -2
  print(X if X<Y else Y)
#+END_SRC

#+RESULTS:
: -2

** switch..case
Python中没有C语言那样的 =switch..case= 分支语句. 一般使用 =if..elif..else= 语句代替,会使用跳转表来实现:
#+BEGIN_SRC python
  def f(x):
      return {
          0: "You typed zero.",
          1: "You typed one.",
          2: "You typed two."
      }.get(x,"You Typed Other Number")

  print(f(1))
  print(f(3))
#+END_SRC

#+RESULTS:
: You typed one.
: You Typed Other Number

* 内部机理

** with语句

包含with语句的代码看的执行过程如下:

1. 计算表达式的值,它会返回一个上下文管理器对象
2. 加载上下文管理器对象的 =__exit_()= 方法以备后用
3. 调用上下文管理器对象的 =__enter__()= 方法
4. 如果with语句中设置了目标对象,则将 =__enter__()= 方法的返回值赋值给目标对象
5. 执行with中的代码看
6. 若步骤5中的代码正常结束,调用上下文管理器对象的 =__exit__()= 方法,其返回值被忽略
7. 若步骤5中的代码执行过程发生异常,调用上下文管理器对象的 =__exit__()= 方法,并将异常类型,值以及traceback信息作为参数传递给 =__exit__()= 方法. 如果 =__exit__()= 返回值为false,则异常会被重新抛出,如果返回值为true,异常被挂起,程序继续执行.

** import语句

* Local Variables Setting:
# Local Variables:
# org-babel-default-header-args:python: ((:session . "none") (:results . "output") (:exports . "code") (:cache))
# org-babel-python-command: "python3"
# End:

